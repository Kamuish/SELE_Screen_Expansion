
screen_expansion.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800100  0000053e  000005b2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000053e  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .stab         000016a4  00000000  00000000  000005b4  2**2
                  CONTENTS, READONLY, DEBUGGING
  3 .stabstr      00000dcf  00000000  00000000  00001c58  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .comment      00000011  00000000  00000000  00002a27  2**0
                  CONTENTS, READONLY
  5 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00002a38  2**2
                  CONTENTS, READONLY

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
   4:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
   8:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
   c:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  10:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  14:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  18:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  1c:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  20:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  24:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  28:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  2c:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  30:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  34:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  38:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  3c:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  40:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  44:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  48:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  4c:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  50:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  54:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  58:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  5c:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  60:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  64:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>

00000068 <__ctors_end>:
  68:	11 24       	eor	r1, r1
  6a:	1f be       	out	0x3f, r1	; 63
  6c:	cf ef       	ldi	r28, 0xFF	; 255
  6e:	d8 e0       	ldi	r29, 0x08	; 8
  70:	de bf       	out	0x3e, r29	; 62
  72:	cd bf       	out	0x3d, r28	; 61
  74:	0e 94 9a 02 	call	0x534	; 0x534 <main>
  78:	0c 94 9d 02 	jmp	0x53a	; 0x53a <_exit>

0000007c <__bad_interrupt>:
  7c:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000080 <ScreenInit>:
	/* Initial commands */

	command = 0x60;
	command |= (1<<EN);
	command &= ~(1<<RS);
	SPIMasterTransmit(command);
  80:	84 e6       	ldi	r24, 0x64	; 100
  82:	0e 94 83 02 	call	0x506	; 0x506 <SPIMasterTransmit>
	command &= ~(1<<EN);
	command &= ~(1<<RS);
	SPIMasterTransmit(command);
  86:	80 e6       	ldi	r24, 0x60	; 96
  88:	0e 94 83 02 	call	0x506	; 0x506 <SPIMasterTransmit>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
  8c:	89 e0       	ldi	r24, 0x09	; 9
  8e:	98 e2       	ldi	r25, 0x28	; 40
  90:	01 97       	sbiw	r24, 0x01	; 1
  92:	f1 f7       	brne	.-4      	; 0x90 <ScreenInit+0x10>
  94:	00 c0       	rjmp	.+0      	; 0x96 <ScreenInit+0x16>
  96:	00 00       	nop
	_delay_ms(41);
	command = 0x60;
	command |= (1<<EN);
	command &= ~(1<<RS);
	SPIMasterTransmit(command);
  98:	84 e6       	ldi	r24, 0x64	; 100
  9a:	0e 94 83 02 	call	0x506	; 0x506 <SPIMasterTransmit>
	command &= ~(1<<EN);
	command &= ~(1<<RS);
	SPIMasterTransmit(command);
  9e:	80 e6       	ldi	r24, 0x60	; 96
  a0:	0e 94 83 02 	call	0x506	; 0x506 <SPIMasterTransmit>
  a4:	89 ef       	ldi	r24, 0xF9	; 249
  a6:	90 e0       	ldi	r25, 0x00	; 0
  a8:	01 97       	sbiw	r24, 0x01	; 1
  aa:	f1 f7       	brne	.-4      	; 0xa8 <ScreenInit+0x28>
  ac:	00 c0       	rjmp	.+0      	; 0xae <ScreenInit+0x2e>
  ae:	00 00       	nop
	_delay_ms(1);
	command = 0x60;
	command |= (1<<EN);
	command &= ~(1<<RS);
	SPIMasterTransmit(command);
  b0:	84 e6       	ldi	r24, 0x64	; 100
  b2:	0e 94 83 02 	call	0x506	; 0x506 <SPIMasterTransmit>
	command &= ~(1<<EN);
	command &= ~(1<<RS);
	SPIMasterTransmit(command);
  b6:	80 e6       	ldi	r24, 0x60	; 96
  b8:	0e 94 83 02 	call	0x506	; 0x506 <SPIMasterTransmit>
  bc:	89 ef       	ldi	r24, 0xF9	; 249
  be:	90 e0       	ldi	r25, 0x00	; 0
  c0:	01 97       	sbiw	r24, 0x01	; 1
  c2:	f1 f7       	brne	.-4      	; 0xc0 <ScreenInit+0x40>
  c4:	00 c0       	rjmp	.+0      	; 0xc6 <ScreenInit+0x46>
  c6:	00 00       	nop
	_delay_ms(1);
	command = 0x20;
	command |= (1<<EN);
	command &= ~(1<<RS);
	SPIMasterTransmit(command);
  c8:	84 e2       	ldi	r24, 0x24	; 36
  ca:	0e 94 83 02 	call	0x506	; 0x506 <SPIMasterTransmit>
	command &= ~(1<<EN);
	command &= ~(1<<RS);
	SPIMasterTransmit(command);
  ce:	80 e2       	ldi	r24, 0x20	; 32
  d0:	0e 94 83 02 	call	0x506	; 0x506 <SPIMasterTransmit>
  d4:	83 ec       	ldi	r24, 0xC3	; 195
  d6:	99 e0       	ldi	r25, 0x09	; 9
  d8:	01 97       	sbiw	r24, 0x01	; 1
  da:	f1 f7       	brne	.-4      	; 0xd8 <ScreenInit+0x58>
  dc:	00 c0       	rjmp	.+0      	; 0xde <ScreenInit+0x5e>
  de:	00 00       	nop
	uint8_t send_instruction;				/* Instruction to be sent */
	send_instruction = high_nibble>>1;		/* Shift high nibble to correct position */
	send_instruction |= (1<<EN);			/* Enable pin high */
	send_instruction &= ~(1<<RS);			/* RS pin low for instruction */

	SPIMasterTransmit(send_instruction);	/* Send instruction */
  e0:	84 e2       	ldi	r24, 0x24	; 36
  e2:	0e 94 83 02 	call	0x506	; 0x506 <SPIMasterTransmit>

	send_instruction &= ~(1<<EN);			/* Enable pin low */

	SPIMasterTransmit(send_instruction);	/* Send again with EN low */
  e6:	80 e2       	ldi	r24, 0x20	; 32
  e8:	0e 94 83 02 	call	0x506	; 0x506 <SPIMasterTransmit>
  ec:	83 ec       	ldi	r24, 0xC3	; 195
  ee:	99 e0       	ldi	r25, 0x09	; 9
  f0:	01 97       	sbiw	r24, 0x01	; 1
  f2:	f1 f7       	brne	.-4      	; 0xf0 <ScreenInit+0x70>
  f4:	00 c0       	rjmp	.+0      	; 0xf6 <ScreenInit+0x76>
  f6:	00 00       	nop

	send_instruction = low_nibble<<3;		/* Shift low nibble to correct position */
	send_instruction |= (1<<EN);			/* Same procedure as for high nibble */
	send_instruction &= ~(1<<RS);

	SPIMasterTransmit(send_instruction);
  f8:	8c e0       	ldi	r24, 0x0C	; 12
  fa:	0e 94 83 02 	call	0x506	; 0x506 <SPIMasterTransmit>

	send_instruction &= ~(1<<EN);
	send_instruction |= (1<<BKL);			/* Backlight pin high to enable baklight */

	SPIMasterTransmit(send_instruction);
  fe:	88 e8       	ldi	r24, 0x88	; 136
 100:	0e 94 83 02 	call	0x506	; 0x506 <SPIMasterTransmit>
 104:	83 ec       	ldi	r24, 0xC3	; 195
 106:	99 e0       	ldi	r25, 0x09	; 9
 108:	01 97       	sbiw	r24, 0x01	; 1
 10a:	f1 f7       	brne	.-4      	; 0x108 <ScreenInit+0x88>
 10c:	00 c0       	rjmp	.+0      	; 0x10e <ScreenInit+0x8e>
 10e:	00 00       	nop
	uint8_t send_instruction;				/* Instruction to be sent */
	send_instruction = high_nibble>>1;		/* Shift high nibble to correct position */
	send_instruction |= (1<<EN);			/* Enable pin high */
	send_instruction &= ~(1<<RS);			/* RS pin low for instruction */

	SPIMasterTransmit(send_instruction);	/* Send instruction */
 110:	84 e0       	ldi	r24, 0x04	; 4
 112:	0e 94 83 02 	call	0x506	; 0x506 <SPIMasterTransmit>

	send_instruction &= ~(1<<EN);			/* Enable pin low */

	SPIMasterTransmit(send_instruction);	/* Send again with EN low */
 116:	80 e0       	ldi	r24, 0x00	; 0
 118:	0e 94 83 02 	call	0x506	; 0x506 <SPIMasterTransmit>
 11c:	83 ec       	ldi	r24, 0xC3	; 195
 11e:	99 e0       	ldi	r25, 0x09	; 9
 120:	01 97       	sbiw	r24, 0x01	; 1
 122:	f1 f7       	brne	.-4      	; 0x120 <ScreenInit+0xa0>
 124:	00 c0       	rjmp	.+0      	; 0x126 <ScreenInit+0xa6>
 126:	00 00       	nop

	send_instruction = low_nibble<<3;		/* Shift low nibble to correct position */
	send_instruction |= (1<<EN);			/* Same procedure as for high nibble */
	send_instruction &= ~(1<<RS);

	SPIMasterTransmit(send_instruction);
 128:	8c e0       	ldi	r24, 0x0C	; 12
 12a:	0e 94 83 02 	call	0x506	; 0x506 <SPIMasterTransmit>

	send_instruction &= ~(1<<EN);
	send_instruction |= (1<<BKL);			/* Backlight pin high to enable baklight */

	SPIMasterTransmit(send_instruction);
 12e:	88 e8       	ldi	r24, 0x88	; 136
 130:	0e 94 83 02 	call	0x506	; 0x506 <SPIMasterTransmit>
 134:	83 ec       	ldi	r24, 0xC3	; 195
 136:	99 e0       	ldi	r25, 0x09	; 9
 138:	01 97       	sbiw	r24, 0x01	; 1
 13a:	f1 f7       	brne	.-4      	; 0x138 <ScreenInit+0xb8>
 13c:	00 c0       	rjmp	.+0      	; 0x13e <ScreenInit+0xbe>
 13e:	00 00       	nop
	uint8_t send_instruction;				/* Instruction to be sent */
	send_instruction = high_nibble>>1;		/* Shift high nibble to correct position */
	send_instruction |= (1<<EN);			/* Enable pin high */
	send_instruction &= ~(1<<RS);			/* RS pin low for instruction */

	SPIMasterTransmit(send_instruction);	/* Send instruction */
 140:	84 e0       	ldi	r24, 0x04	; 4
 142:	0e 94 83 02 	call	0x506	; 0x506 <SPIMasterTransmit>

	send_instruction &= ~(1<<EN);			/* Enable pin low */

	SPIMasterTransmit(send_instruction);	/* Send again with EN low */
 146:	80 e0       	ldi	r24, 0x00	; 0
 148:	0e 94 83 02 	call	0x506	; 0x506 <SPIMasterTransmit>
 14c:	83 ec       	ldi	r24, 0xC3	; 195
 14e:	99 e0       	ldi	r25, 0x09	; 9
 150:	01 97       	sbiw	r24, 0x01	; 1
 152:	f1 f7       	brne	.-4      	; 0x150 <ScreenInit+0xd0>
 154:	00 c0       	rjmp	.+0      	; 0x156 <ScreenInit+0xd6>
 156:	00 00       	nop

	send_instruction = low_nibble<<3;		/* Shift low nibble to correct position */
	send_instruction |= (1<<EN);			/* Same procedure as for high nibble */
	send_instruction &= ~(1<<RS);

	SPIMasterTransmit(send_instruction);
 158:	84 e4       	ldi	r24, 0x44	; 68
 15a:	0e 94 83 02 	call	0x506	; 0x506 <SPIMasterTransmit>

	send_instruction &= ~(1<<EN);
	send_instruction |= (1<<BKL);			/* Backlight pin high to enable baklight */

	SPIMasterTransmit(send_instruction);
 15e:	80 ec       	ldi	r24, 0xC0	; 192
 160:	0e 94 83 02 	call	0x506	; 0x506 <SPIMasterTransmit>
 164:	83 ec       	ldi	r24, 0xC3	; 195
 166:	99 e0       	ldi	r25, 0x09	; 9
 168:	01 97       	sbiw	r24, 0x01	; 1
 16a:	f1 f7       	brne	.-4      	; 0x168 <ScreenInit+0xe8>
 16c:	00 c0       	rjmp	.+0      	; 0x16e <ScreenInit+0xee>
 16e:	00 00       	nop
	uint8_t send_instruction;				/* Instruction to be sent */
	send_instruction = high_nibble>>1;		/* Shift high nibble to correct position */
	send_instruction |= (1<<EN);			/* Enable pin high */
	send_instruction &= ~(1<<RS);			/* RS pin low for instruction */

	SPIMasterTransmit(send_instruction);	/* Send instruction */
 170:	84 e0       	ldi	r24, 0x04	; 4
 172:	0e 94 83 02 	call	0x506	; 0x506 <SPIMasterTransmit>

	send_instruction &= ~(1<<EN);			/* Enable pin low */

	SPIMasterTransmit(send_instruction);	/* Send again with EN low */
 176:	80 e0       	ldi	r24, 0x00	; 0
 178:	0e 94 83 02 	call	0x506	; 0x506 <SPIMasterTransmit>
 17c:	83 ec       	ldi	r24, 0xC3	; 195
 17e:	99 e0       	ldi	r25, 0x09	; 9
 180:	01 97       	sbiw	r24, 0x01	; 1
 182:	f1 f7       	brne	.-4      	; 0x180 <ScreenInit+0x100>
 184:	00 c0       	rjmp	.+0      	; 0x186 <ScreenInit+0x106>
 186:	00 00       	nop

	send_instruction = low_nibble<<3;		/* Shift low nibble to correct position */
	send_instruction |= (1<<EN);			/* Same procedure as for high nibble */
	send_instruction &= ~(1<<RS);

	SPIMasterTransmit(send_instruction);
 188:	84 e3       	ldi	r24, 0x34	; 52
 18a:	0e 94 83 02 	call	0x506	; 0x506 <SPIMasterTransmit>

	send_instruction &= ~(1<<EN);
	send_instruction |= (1<<BKL);			/* Backlight pin high to enable baklight */

	SPIMasterTransmit(send_instruction);
 18e:	80 eb       	ldi	r24, 0xB0	; 176
 190:	0e 94 83 02 	call	0x506	; 0x506 <SPIMasterTransmit>
 194:	83 ec       	ldi	r24, 0xC3	; 195
 196:	99 e0       	ldi	r25, 0x09	; 9
 198:	01 97       	sbiw	r24, 0x01	; 1
 19a:	f1 f7       	brne	.-4      	; 0x198 <ScreenInit+0x118>
 19c:	00 c0       	rjmp	.+0      	; 0x19e <ScreenInit+0x11e>
 19e:	00 00       	nop
 1a0:	08 95       	ret

000001a2 <ScreenInstruction>:
	/* Mode Set */

	ScreenInstruction(LCD_MODE_DEFAULT);			/* Default entry mode. Shifts to the right */
}

void ScreenInstruction(uint8_t instruction) {
 1a2:	cf 93       	push	r28
 1a4:	df 93       	push	r29
	/* Sends an instruction to the screen
	 * uint8_t instruction - instruction to be sent
	 * Returns: void.
	 */

	uint8_t high_nibble = (instruction)&0xF0;	/* High 4bit nibble of the character */
 1a6:	48 2f       	mov	r20, r24
 1a8:	40 7f       	andi	r20, 0xF0	; 240
 1aa:	50 e0       	ldi	r21, 0x00	; 0
 1ac:	90 e0       	ldi	r25, 0x00	; 0
	uint8_t NO_OF_BITS = sizeof(nibble)*8; 	/* Number of bits the nibble */
	uint8_t rev_nibble = 0;					/* Reversed nibble temporary variable */

	for (int i = 0; i < NO_OF_BITS; i++) {	/* Iterate through the bits */
		if((nibble & (1 << i)))
		   rev_nibble |= 1 << ((NO_OF_BITS - 1) - i);	/* Build reversed nibble */
 1ae:	29 2f       	mov	r18, r25
 1b0:	28 60       	ori	r18, 0x08	; 8
 1b2:	44 fd       	sbrc	r20, 4
 1b4:	92 2f       	mov	r25, r18
 1b6:	29 2f       	mov	r18, r25
 1b8:	24 60       	ori	r18, 0x04	; 4
 1ba:	45 fd       	sbrc	r20, 5
 1bc:	92 2f       	mov	r25, r18
 1be:	29 2f       	mov	r18, r25
 1c0:	22 60       	ori	r18, 0x02	; 2
 1c2:	46 fd       	sbrc	r20, 6
 1c4:	92 2f       	mov	r25, r18
 1c6:	c9 2f       	mov	r28, r25
 1c8:	c1 60       	ori	r28, 0x01	; 1
	 * uint8_t instruction - instruction to be sent
	 * Returns: void.
	 */

	uint8_t high_nibble = (instruction)&0xF0;	/* High 4bit nibble of the character */
	uint8_t low_nibble  = (instruction)&0x0F;	/* Low 4bit nibble of the character */
 1ca:	28 2f       	mov	r18, r24
 1cc:	2f 70       	andi	r18, 0x0F	; 15
 1ce:	30 e0       	ldi	r19, 0x00	; 0
 1d0:	80 ff       	sbrs	r24, 0
 1d2:	42 c0       	rjmp	.+132    	; 0x258 <ScreenInstruction+0xb6>
 1d4:	80 e8       	ldi	r24, 0x80	; 128
	uint8_t NO_OF_BITS = sizeof(nibble)*8; 	/* Number of bits the nibble */
	uint8_t rev_nibble = 0;					/* Reversed nibble temporary variable */

	for (int i = 0; i < NO_OF_BITS; i++) {	/* Iterate through the bits */
		if((nibble & (1 << i)))
		   rev_nibble |= 1 << ((NO_OF_BITS - 1) - i);	/* Build reversed nibble */
 1d6:	d8 2f       	mov	r29, r24
 1d8:	d0 64       	ori	r29, 0x40	; 64
 1da:	21 fd       	sbrc	r18, 1
 1dc:	8d 2f       	mov	r24, r29
 1de:	d8 2f       	mov	r29, r24
 1e0:	d0 62       	ori	r29, 0x20	; 32
 1e2:	22 ff       	sbrs	r18, 2
 1e4:	d8 2f       	mov	r29, r24
 1e6:	8d 2f       	mov	r24, r29
 1e8:	80 61       	ori	r24, 0x10	; 16

	uint8_t NO_OF_BITS = sizeof(nibble)*8; 	/* Number of bits the nibble */
	uint8_t rev_nibble = 0;					/* Reversed nibble temporary variable */

	for (int i = 0; i < NO_OF_BITS; i++) {	/* Iterate through the bits */
		if((nibble & (1 << i)))
 1ea:	35 95       	asr	r19
 1ec:	27 95       	ror	r18
 1ee:	35 95       	asr	r19
 1f0:	27 95       	ror	r18
 1f2:	35 95       	asr	r19
 1f4:	27 95       	ror	r18
 1f6:	23 2b       	or	r18, r19
 1f8:	09 f0       	breq	.+2      	; 0x1fc <ScreenInstruction+0x5a>
 1fa:	d8 2f       	mov	r29, r24
 1fc:	44 0f       	add	r20, r20
 1fe:	45 2f       	mov	r20, r21
 200:	44 1f       	adc	r20, r20
 202:	55 0b       	sbc	r21, r21
 204:	45 2b       	or	r20, r21
 206:	09 f4       	brne	.+2      	; 0x20a <ScreenInstruction+0x68>
 208:	c9 2f       	mov	r28, r25
	uint8_t high_nibble = (instruction)&0xF0;	/* High 4bit nibble of the character */
	uint8_t low_nibble  = (instruction)&0x0F;	/* Low 4bit nibble of the character */

	/* if (SPI) reverse the instruction before sending */

	high_nibble = ReverseNibble(high_nibble)<<4;
 20a:	c2 95       	swap	r28
 20c:	c0 7f       	andi	r28, 0xF0	; 240
	low_nibble 	= ReverseNibble(low_nibble)>>4;

	/* Send high nibble */

	uint8_t send_instruction;				/* Instruction to be sent */
	send_instruction = high_nibble>>1;		/* Shift high nibble to correct position */
 20e:	c6 95       	lsr	r28
	send_instruction |= (1<<EN);			/* Enable pin high */
	send_instruction &= ~(1<<RS);			/* RS pin low for instruction */

	SPIMasterTransmit(send_instruction);	/* Send instruction */
 210:	8c 2f       	mov	r24, r28
 212:	84 60       	ori	r24, 0x04	; 4
 214:	0e 94 83 02 	call	0x506	; 0x506 <SPIMasterTransmit>

	send_instruction &= ~(1<<EN);			/* Enable pin low */

	SPIMasterTransmit(send_instruction);	/* Send again with EN low */
 218:	8c 2f       	mov	r24, r28
 21a:	0e 94 83 02 	call	0x506	; 0x506 <SPIMasterTransmit>
 21e:	83 ec       	ldi	r24, 0xC3	; 195
 220:	99 e0       	ldi	r25, 0x09	; 9
 222:	01 97       	sbiw	r24, 0x01	; 1
 224:	f1 f7       	brne	.-4      	; 0x222 <ScreenInstruction+0x80>
 226:	00 c0       	rjmp	.+0      	; 0x228 <ScreenInstruction+0x86>
 228:	00 00       	nop
	uint8_t low_nibble  = (instruction)&0x0F;	/* Low 4bit nibble of the character */

	/* if (SPI) reverse the instruction before sending */

	high_nibble = ReverseNibble(high_nibble)<<4;
	low_nibble 	= ReverseNibble(low_nibble)>>4;
 22a:	cd 2f       	mov	r28, r29
 22c:	c2 95       	swap	r28
 22e:	cf 70       	andi	r28, 0x0F	; 15

	_delay_ms(10);							/* Delay between screen writes */

	/* Send low nibble */

	send_instruction = low_nibble<<3;		/* Shift low nibble to correct position */
 230:	cc 0f       	add	r28, r28
 232:	cc 0f       	add	r28, r28
 234:	cc 0f       	add	r28, r28
	send_instruction |= (1<<EN);			/* Same procedure as for high nibble */
	send_instruction &= ~(1<<RS);

	SPIMasterTransmit(send_instruction);
 236:	8c 2f       	mov	r24, r28
 238:	84 60       	ori	r24, 0x04	; 4
 23a:	0e 94 83 02 	call	0x506	; 0x506 <SPIMasterTransmit>

	send_instruction &= ~(1<<EN);
	send_instruction |= (1<<BKL);			/* Backlight pin high to enable baklight */

	SPIMasterTransmit(send_instruction);
 23e:	8c 2f       	mov	r24, r28
 240:	80 68       	ori	r24, 0x80	; 128
 242:	0e 94 83 02 	call	0x506	; 0x506 <SPIMasterTransmit>
 246:	83 ec       	ldi	r24, 0xC3	; 195
 248:	99 e0       	ldi	r25, 0x09	; 9
 24a:	01 97       	sbiw	r24, 0x01	; 1
 24c:	f1 f7       	brne	.-4      	; 0x24a <ScreenInstruction+0xa8>
 24e:	00 c0       	rjmp	.+0      	; 0x250 <ScreenInstruction+0xae>
 250:	00 00       	nop

	_delay_ms(10);
}
 252:	df 91       	pop	r29
 254:	cf 91       	pop	r28
 256:	08 95       	ret
 258:	80 e0       	ldi	r24, 0x00	; 0
 25a:	bd cf       	rjmp	.-134    	; 0x1d6 <ScreenInstruction+0x34>

0000025c <ScreenData>:

void ScreenData(uint8_t data) {
 25c:	cf 93       	push	r28
 25e:	df 93       	push	r29
	/* Sends data to the screen.
	 * uint8_t data - data to be displayed
	 * Returns: void.
	 */

	uint8_t high_nibble = (data)&0xF0;	/* High 4bit nibble of the character */
 260:	48 2f       	mov	r20, r24
 262:	40 7f       	andi	r20, 0xF0	; 240
 264:	50 e0       	ldi	r21, 0x00	; 0
 266:	90 e0       	ldi	r25, 0x00	; 0
	uint8_t NO_OF_BITS = sizeof(nibble)*8; 	/* Number of bits the nibble */
	uint8_t rev_nibble = 0;					/* Reversed nibble temporary variable */

	for (int i = 0; i < NO_OF_BITS; i++) {	/* Iterate through the bits */
		if((nibble & (1 << i)))
		   rev_nibble |= 1 << ((NO_OF_BITS - 1) - i);	/* Build reversed nibble */
 268:	c9 2f       	mov	r28, r25
 26a:	c8 60       	ori	r28, 0x08	; 8
 26c:	44 fd       	sbrc	r20, 4
 26e:	9c 2f       	mov	r25, r28
 270:	29 2f       	mov	r18, r25
 272:	24 60       	ori	r18, 0x04	; 4
 274:	45 fd       	sbrc	r20, 5
 276:	92 2f       	mov	r25, r18
 278:	29 2f       	mov	r18, r25
 27a:	22 60       	ori	r18, 0x02	; 2
 27c:	46 fd       	sbrc	r20, 6
 27e:	92 2f       	mov	r25, r18
 280:	c9 2f       	mov	r28, r25
 282:	c1 60       	ori	r28, 0x01	; 1
	 * uint8_t data - data to be displayed
	 * Returns: void.
	 */

	uint8_t high_nibble = (data)&0xF0;	/* High 4bit nibble of the character */
	uint8_t low_nibble  = (data)&0x0F;	/* Low 4bit nibble of the character */
 284:	28 2f       	mov	r18, r24
 286:	2f 70       	andi	r18, 0x0F	; 15
 288:	30 e0       	ldi	r19, 0x00	; 0
 28a:	80 ff       	sbrs	r24, 0
 28c:	40 c0       	rjmp	.+128    	; 0x30e <ScreenData+0xb2>
 28e:	60 e8       	ldi	r22, 0x80	; 128
	uint8_t NO_OF_BITS = sizeof(nibble)*8; 	/* Number of bits the nibble */
	uint8_t rev_nibble = 0;					/* Reversed nibble temporary variable */

	for (int i = 0; i < NO_OF_BITS; i++) {	/* Iterate through the bits */
		if((nibble & (1 << i)))
		   rev_nibble |= 1 << ((NO_OF_BITS - 1) - i);	/* Build reversed nibble */
 290:	d6 2f       	mov	r29, r22
 292:	d0 64       	ori	r29, 0x40	; 64
 294:	21 fd       	sbrc	r18, 1
 296:	6d 2f       	mov	r22, r29
 298:	d6 2f       	mov	r29, r22
 29a:	d0 62       	ori	r29, 0x20	; 32
 29c:	22 ff       	sbrs	r18, 2
 29e:	d6 2f       	mov	r29, r22
 2a0:	6d 2f       	mov	r22, r29
 2a2:	60 61       	ori	r22, 0x10	; 16

	uint8_t NO_OF_BITS = sizeof(nibble)*8; 	/* Number of bits the nibble */
	uint8_t rev_nibble = 0;					/* Reversed nibble temporary variable */

	for (int i = 0; i < NO_OF_BITS; i++) {	/* Iterate through the bits */
		if((nibble & (1 << i)))
 2a4:	35 95       	asr	r19
 2a6:	27 95       	ror	r18
 2a8:	35 95       	asr	r19
 2aa:	27 95       	ror	r18
 2ac:	35 95       	asr	r19
 2ae:	27 95       	ror	r18
 2b0:	23 2b       	or	r18, r19
 2b2:	09 f0       	breq	.+2      	; 0x2b6 <ScreenData+0x5a>
 2b4:	d6 2f       	mov	r29, r22
 2b6:	44 0f       	add	r20, r20
 2b8:	45 2f       	mov	r20, r21
 2ba:	44 1f       	adc	r20, r20
 2bc:	55 0b       	sbc	r21, r21
 2be:	45 2b       	or	r20, r21
 2c0:	09 f4       	brne	.+2      	; 0x2c4 <ScreenData+0x68>
 2c2:	c9 2f       	mov	r28, r25
	low_nibble = ReverseNibble(low_nibble);		/* Reverse low nibble */

	/* Send high nibble */

	uint8_t send_data;							/* Data to be sent */
	send_data = high_nibble>>1;					/* Shift high nibble to correct position */
 2c4:	c6 95       	lsr	r28
	send_data |= (1<<RS)|(1<<EN)|(1<<BKL);		/* RS high for data, EN high, BKL high */

	SPIMasterTransmit(send_data);				/* Send data */
 2c6:	8c 2f       	mov	r24, r28
 2c8:	86 68       	ori	r24, 0x86	; 134
 2ca:	0e 94 83 02 	call	0x506	; 0x506 <SPIMasterTransmit>

	send_data &= ~(1<<EN);						/* Enable low */
 2ce:	8c 2f       	mov	r24, r28
 2d0:	8b 7f       	andi	r24, 0xFB	; 251

	SPIMasterTransmit(send_data);				/* Send data again with enable low */
 2d2:	82 68       	ori	r24, 0x82	; 130
 2d4:	0e 94 83 02 	call	0x506	; 0x506 <SPIMasterTransmit>
 2d8:	83 ec       	ldi	r24, 0xC3	; 195
 2da:	99 e0       	ldi	r25, 0x09	; 9
 2dc:	01 97       	sbiw	r24, 0x01	; 1
 2de:	f1 f7       	brne	.-4      	; 0x2dc <ScreenData+0x80>
 2e0:	00 c0       	rjmp	.+0      	; 0x2e2 <ScreenData+0x86>
 2e2:	00 00       	nop

	_delay_ms(10);

	/* Send low nibble */

	send_data = low_nibble<<3;					/* Shift low nibble to correct position */
 2e4:	cd 2f       	mov	r28, r29
 2e6:	cc 0f       	add	r28, r28
 2e8:	cc 0f       	add	r28, r28
 2ea:	cc 0f       	add	r28, r28
	send_data |= (1<<RS)|(1<<EN)|(1<<BKL);		/* Same procedure as for high nibble */

	SPIMasterTransmit(send_data);
 2ec:	8c 2f       	mov	r24, r28
 2ee:	86 68       	ori	r24, 0x86	; 134
 2f0:	0e 94 83 02 	call	0x506	; 0x506 <SPIMasterTransmit>

	send_data &= ~(1<<EN);

	SPIMasterTransmit(send_data);
 2f4:	8c 2f       	mov	r24, r28
 2f6:	82 68       	ori	r24, 0x82	; 130
 2f8:	0e 94 83 02 	call	0x506	; 0x506 <SPIMasterTransmit>
 2fc:	83 ec       	ldi	r24, 0xC3	; 195
 2fe:	99 e0       	ldi	r25, 0x09	; 9
 300:	01 97       	sbiw	r24, 0x01	; 1
 302:	f1 f7       	brne	.-4      	; 0x300 <ScreenData+0xa4>
 304:	00 c0       	rjmp	.+0      	; 0x306 <ScreenData+0xaa>
 306:	00 00       	nop

	_delay_ms(10);

}
 308:	df 91       	pop	r29
 30a:	cf 91       	pop	r28
 30c:	08 95       	ret
 30e:	60 e0       	ldi	r22, 0x00	; 0
 310:	bf cf       	rjmp	.-130    	; 0x290 <ScreenData+0x34>

00000312 <PutChar>:

/* Higher level screen functions */

void PutChar(uint8_t character){
 312:	cf 93       	push	r28
 314:	df 93       	push	r29
	/* Sends data to the screen.
	 * uint8_t data - data to be displayed
	 * Returns: void.
	 */

	uint8_t high_nibble = (data)&0xF0;	/* High 4bit nibble of the character */
 316:	48 2f       	mov	r20, r24
 318:	40 7f       	andi	r20, 0xF0	; 240
 31a:	50 e0       	ldi	r21, 0x00	; 0
 31c:	90 e0       	ldi	r25, 0x00	; 0
	uint8_t NO_OF_BITS = sizeof(nibble)*8; 	/* Number of bits the nibble */
	uint8_t rev_nibble = 0;					/* Reversed nibble temporary variable */

	for (int i = 0; i < NO_OF_BITS; i++) {	/* Iterate through the bits */
		if((nibble & (1 << i)))
		   rev_nibble |= 1 << ((NO_OF_BITS - 1) - i);	/* Build reversed nibble */
 31e:	c9 2f       	mov	r28, r25
 320:	c8 60       	ori	r28, 0x08	; 8
 322:	44 fd       	sbrc	r20, 4
 324:	9c 2f       	mov	r25, r28
 326:	29 2f       	mov	r18, r25
 328:	24 60       	ori	r18, 0x04	; 4
 32a:	45 fd       	sbrc	r20, 5
 32c:	92 2f       	mov	r25, r18
 32e:	29 2f       	mov	r18, r25
 330:	22 60       	ori	r18, 0x02	; 2
 332:	46 fd       	sbrc	r20, 6
 334:	92 2f       	mov	r25, r18
 336:	c9 2f       	mov	r28, r25
 338:	c1 60       	ori	r28, 0x01	; 1
	 * uint8_t data - data to be displayed
	 * Returns: void.
	 */

	uint8_t high_nibble = (data)&0xF0;	/* High 4bit nibble of the character */
	uint8_t low_nibble  = (data)&0x0F;	/* Low 4bit nibble of the character */
 33a:	28 2f       	mov	r18, r24
 33c:	2f 70       	andi	r18, 0x0F	; 15
 33e:	30 e0       	ldi	r19, 0x00	; 0
 340:	80 ff       	sbrs	r24, 0
 342:	40 c0       	rjmp	.+128    	; 0x3c4 <PutChar+0xb2>
 344:	60 e8       	ldi	r22, 0x80	; 128
	uint8_t NO_OF_BITS = sizeof(nibble)*8; 	/* Number of bits the nibble */
	uint8_t rev_nibble = 0;					/* Reversed nibble temporary variable */

	for (int i = 0; i < NO_OF_BITS; i++) {	/* Iterate through the bits */
		if((nibble & (1 << i)))
		   rev_nibble |= 1 << ((NO_OF_BITS - 1) - i);	/* Build reversed nibble */
 346:	d6 2f       	mov	r29, r22
 348:	d0 64       	ori	r29, 0x40	; 64
 34a:	21 fd       	sbrc	r18, 1
 34c:	6d 2f       	mov	r22, r29
 34e:	d6 2f       	mov	r29, r22
 350:	d0 62       	ori	r29, 0x20	; 32
 352:	22 ff       	sbrs	r18, 2
 354:	d6 2f       	mov	r29, r22
 356:	6d 2f       	mov	r22, r29
 358:	60 61       	ori	r22, 0x10	; 16

	uint8_t NO_OF_BITS = sizeof(nibble)*8; 	/* Number of bits the nibble */
	uint8_t rev_nibble = 0;					/* Reversed nibble temporary variable */

	for (int i = 0; i < NO_OF_BITS; i++) {	/* Iterate through the bits */
		if((nibble & (1 << i)))
 35a:	35 95       	asr	r19
 35c:	27 95       	ror	r18
 35e:	35 95       	asr	r19
 360:	27 95       	ror	r18
 362:	35 95       	asr	r19
 364:	27 95       	ror	r18
 366:	23 2b       	or	r18, r19
 368:	09 f0       	breq	.+2      	; 0x36c <PutChar+0x5a>
 36a:	d6 2f       	mov	r29, r22
 36c:	44 0f       	add	r20, r20
 36e:	45 2f       	mov	r20, r21
 370:	44 1f       	adc	r20, r20
 372:	55 0b       	sbc	r21, r21
 374:	45 2b       	or	r20, r21
 376:	09 f4       	brne	.+2      	; 0x37a <PutChar+0x68>
 378:	c9 2f       	mov	r28, r25
	low_nibble = ReverseNibble(low_nibble);		/* Reverse low nibble */

	/* Send high nibble */

	uint8_t send_data;							/* Data to be sent */
	send_data = high_nibble>>1;					/* Shift high nibble to correct position */
 37a:	c6 95       	lsr	r28
	send_data |= (1<<RS)|(1<<EN)|(1<<BKL);		/* RS high for data, EN high, BKL high */

	SPIMasterTransmit(send_data);				/* Send data */
 37c:	8c 2f       	mov	r24, r28
 37e:	86 68       	ori	r24, 0x86	; 134
 380:	0e 94 83 02 	call	0x506	; 0x506 <SPIMasterTransmit>

	send_data &= ~(1<<EN);						/* Enable low */
 384:	8c 2f       	mov	r24, r28
 386:	8b 7f       	andi	r24, 0xFB	; 251

	SPIMasterTransmit(send_data);				/* Send data again with enable low */
 388:	82 68       	ori	r24, 0x82	; 130
 38a:	0e 94 83 02 	call	0x506	; 0x506 <SPIMasterTransmit>
 38e:	83 ec       	ldi	r24, 0xC3	; 195
 390:	99 e0       	ldi	r25, 0x09	; 9
 392:	01 97       	sbiw	r24, 0x01	; 1
 394:	f1 f7       	brne	.-4      	; 0x392 <PutChar+0x80>
 396:	00 c0       	rjmp	.+0      	; 0x398 <PutChar+0x86>
 398:	00 00       	nop

	_delay_ms(10);

	/* Send low nibble */

	send_data = low_nibble<<3;					/* Shift low nibble to correct position */
 39a:	cd 2f       	mov	r28, r29
 39c:	cc 0f       	add	r28, r28
 39e:	cc 0f       	add	r28, r28
 3a0:	cc 0f       	add	r28, r28
	send_data |= (1<<RS)|(1<<EN)|(1<<BKL);		/* Same procedure as for high nibble */

	SPIMasterTransmit(send_data);
 3a2:	8c 2f       	mov	r24, r28
 3a4:	86 68       	ori	r24, 0x86	; 134
 3a6:	0e 94 83 02 	call	0x506	; 0x506 <SPIMasterTransmit>

	send_data &= ~(1<<EN);

	SPIMasterTransmit(send_data);
 3aa:	8c 2f       	mov	r24, r28
 3ac:	82 68       	ori	r24, 0x82	; 130
 3ae:	0e 94 83 02 	call	0x506	; 0x506 <SPIMasterTransmit>
 3b2:	83 ec       	ldi	r24, 0xC3	; 195
 3b4:	99 e0       	ldi	r25, 0x09	; 9
 3b6:	01 97       	sbiw	r24, 0x01	; 1
 3b8:	f1 f7       	brne	.-4      	; 0x3b6 <PutChar+0xa4>
 3ba:	00 c0       	rjmp	.+0      	; 0x3bc <PutChar+0xaa>
 3bc:	00 00       	nop
	 * uint8_t character - the character to write
	 * Returns: void.
	 */

	ScreenData(character);		/* Send data to screen */
}
 3be:	df 91       	pop	r29
 3c0:	cf 91       	pop	r28
 3c2:	08 95       	ret
 3c4:	60 e0       	ldi	r22, 0x00	; 0
 3c6:	bf cf       	rjmp	.-130    	; 0x346 <PutChar+0x34>

000003c8 <PutString>:

void PutString(uint8_t string[], uint16_t length) {
 3c8:	ef 92       	push	r14
 3ca:	ff 92       	push	r15
 3cc:	0f 93       	push	r16
 3ce:	1f 93       	push	r17
 3d0:	cf 93       	push	r28
 3d2:	df 93       	push	r29
 3d4:	8b 01       	movw	r16, r22
 3d6:	11 27       	eor	r17, r17
	 * uint16_t length - size of the character array obtained from sizeof(string)
	 * Returns: void.
	 */
	uint8_t NO_OF_CHARS = length / sizeof(uint8_t);

	for (int i = 0; i < NO_OF_CHARS; i++) { 	/* Iterate through the char array */
 3d8:	01 15       	cp	r16, r1
 3da:	11 05       	cpc	r17, r1
 3dc:	09 f4       	brne	.+2      	; 0x3e0 <PutString+0x18>
 3de:	58 c0       	rjmp	.+176    	; 0x490 <PutString+0xc8>
 3e0:	7c 01       	movw	r14, r24
 3e2:	08 0f       	add	r16, r24
 3e4:	19 1f       	adc	r17, r25
 3e6:	44 c0       	rjmp	.+136    	; 0x470 <PutString+0xa8>

	uint8_t NO_OF_BITS = sizeof(nibble)*8; 	/* Number of bits the nibble */
	uint8_t rev_nibble = 0;					/* Reversed nibble temporary variable */

	for (int i = 0; i < NO_OF_BITS; i++) {	/* Iterate through the bits */
		if((nibble & (1 << i)))
 3e8:	34 e0       	ldi	r19, 0x04	; 4
 3ea:	80 e0       	ldi	r24, 0x00	; 0
 3ec:	95 fd       	sbrc	r25, 5
		   rev_nibble |= 1 << ((NO_OF_BITS - 1) - i);	/* Build reversed nibble */
 3ee:	83 2f       	mov	r24, r19

	uint8_t NO_OF_BITS = sizeof(nibble)*8; 	/* Number of bits the nibble */
	uint8_t rev_nibble = 0;					/* Reversed nibble temporary variable */

	for (int i = 0; i < NO_OF_BITS; i++) {	/* Iterate through the bits */
		if((nibble & (1 << i)))
 3f0:	96 fd       	sbrc	r25, 6
		   rev_nibble |= 1 << ((NO_OF_BITS - 1) - i);	/* Build reversed nibble */
 3f2:	82 60       	ori	r24, 0x02	; 2

	uint8_t NO_OF_BITS = sizeof(nibble)*8; 	/* Number of bits the nibble */
	uint8_t rev_nibble = 0;					/* Reversed nibble temporary variable */

	for (int i = 0; i < NO_OF_BITS; i++) {	/* Iterate through the bits */
		if((nibble & (1 << i)))
 3f4:	44 0f       	add	r20, r20
 3f6:	45 2f       	mov	r20, r21
 3f8:	44 1f       	adc	r20, r20
 3fa:	55 0b       	sbc	r21, r21
 3fc:	45 2b       	or	r20, r21
 3fe:	09 f0       	breq	.+2      	; 0x402 <PutString+0x3a>
		   rev_nibble |= 1 << ((NO_OF_BITS - 1) - i);	/* Build reversed nibble */
 400:	81 60       	ori	r24, 0x01	; 1

	uint8_t NO_OF_BITS = sizeof(nibble)*8; 	/* Number of bits the nibble */
	uint8_t rev_nibble = 0;					/* Reversed nibble temporary variable */

	for (int i = 0; i < NO_OF_BITS; i++) {	/* Iterate through the bits */
		if((nibble & (1 << i)))
 402:	30 e0       	ldi	r19, 0x00	; 0
 404:	90 fd       	sbrc	r25, 0
 406:	41 c0       	rjmp	.+130    	; 0x48a <PutString+0xc2>
 408:	40 e4       	ldi	r20, 0x40	; 64
	 * uint8_t nibble - nibble to reverse
	 * Returns: inverted nibble.
	 */

	uint8_t NO_OF_BITS = sizeof(nibble)*8; 	/* Number of bits the nibble */
	uint8_t rev_nibble = 0;					/* Reversed nibble temporary variable */
 40a:	d0 e0       	ldi	r29, 0x00	; 0

	for (int i = 0; i < NO_OF_BITS; i++) {	/* Iterate through the bits */
		if((nibble & (1 << i)))
 40c:	91 fd       	sbrc	r25, 1
		   rev_nibble |= 1 << ((NO_OF_BITS - 1) - i);	/* Build reversed nibble */
 40e:	d4 2f       	mov	r29, r20

	uint8_t NO_OF_BITS = sizeof(nibble)*8; 	/* Number of bits the nibble */
	uint8_t rev_nibble = 0;					/* Reversed nibble temporary variable */

	for (int i = 0; i < NO_OF_BITS; i++) {	/* Iterate through the bits */
		if((nibble & (1 << i)))
 410:	92 fd       	sbrc	r25, 2
		   rev_nibble |= 1 << ((NO_OF_BITS - 1) - i);	/* Build reversed nibble */
 412:	d0 62       	ori	r29, 0x20	; 32

	uint8_t NO_OF_BITS = sizeof(nibble)*8; 	/* Number of bits the nibble */
	uint8_t rev_nibble = 0;					/* Reversed nibble temporary variable */

	for (int i = 0; i < NO_OF_BITS; i++) {	/* Iterate through the bits */
		if((nibble & (1 << i)))
 414:	35 95       	asr	r19
 416:	27 95       	ror	r18
 418:	35 95       	asr	r19
 41a:	27 95       	ror	r18
 41c:	35 95       	asr	r19
 41e:	27 95       	ror	r18
 420:	23 2b       	or	r18, r19
 422:	09 f0       	breq	.+2      	; 0x426 <PutString+0x5e>
		   rev_nibble |= 1 << ((NO_OF_BITS - 1) - i);	/* Build reversed nibble */
 424:	d0 61       	ori	r29, 0x10	; 16
	low_nibble = ReverseNibble(low_nibble);		/* Reverse low nibble */

	/* Send high nibble */

	uint8_t send_data;							/* Data to be sent */
	send_data = high_nibble>>1;					/* Shift high nibble to correct position */
 426:	c8 2f       	mov	r28, r24
 428:	c6 95       	lsr	r28
	send_data |= (1<<RS)|(1<<EN)|(1<<BKL);		/* RS high for data, EN high, BKL high */

	SPIMasterTransmit(send_data);				/* Send data */
 42a:	8c 2f       	mov	r24, r28
 42c:	86 68       	ori	r24, 0x86	; 134
 42e:	0e 94 83 02 	call	0x506	; 0x506 <SPIMasterTransmit>

	send_data &= ~(1<<EN);						/* Enable low */
 432:	8c 2f       	mov	r24, r28
 434:	8b 7f       	andi	r24, 0xFB	; 251

	SPIMasterTransmit(send_data);				/* Send data again with enable low */
 436:	82 68       	ori	r24, 0x82	; 130
 438:	0e 94 83 02 	call	0x506	; 0x506 <SPIMasterTransmit>
 43c:	83 ec       	ldi	r24, 0xC3	; 195
 43e:	99 e0       	ldi	r25, 0x09	; 9
 440:	01 97       	sbiw	r24, 0x01	; 1
 442:	f1 f7       	brne	.-4      	; 0x440 <PutString+0x78>
 444:	00 c0       	rjmp	.+0      	; 0x446 <PutString+0x7e>
 446:	00 00       	nop

	_delay_ms(10);

	/* Send low nibble */

	send_data = low_nibble<<3;					/* Shift low nibble to correct position */
 448:	dd 0f       	add	r29, r29
 44a:	dd 0f       	add	r29, r29
 44c:	dd 0f       	add	r29, r29
	send_data |= (1<<RS)|(1<<EN)|(1<<BKL);		/* Same procedure as for high nibble */

	SPIMasterTransmit(send_data);
 44e:	8d 2f       	mov	r24, r29
 450:	86 68       	ori	r24, 0x86	; 134
 452:	0e 94 83 02 	call	0x506	; 0x506 <SPIMasterTransmit>

	send_data &= ~(1<<EN);

	SPIMasterTransmit(send_data);
 456:	8d 2f       	mov	r24, r29
 458:	82 68       	ori	r24, 0x82	; 130
 45a:	0e 94 83 02 	call	0x506	; 0x506 <SPIMasterTransmit>
 45e:	e3 ec       	ldi	r30, 0xC3	; 195
 460:	f9 e0       	ldi	r31, 0x09	; 9
 462:	31 97       	sbiw	r30, 0x01	; 1
 464:	f1 f7       	brne	.-4      	; 0x462 <PutString+0x9a>
 466:	00 c0       	rjmp	.+0      	; 0x468 <PutString+0xa0>
 468:	00 00       	nop
	 * uint16_t length - size of the character array obtained from sizeof(string)
	 * Returns: void.
	 */
	uint8_t NO_OF_CHARS = length / sizeof(uint8_t);

	for (int i = 0; i < NO_OF_CHARS; i++) { 	/* Iterate through the char array */
 46a:	e0 16       	cp	r14, r16
 46c:	f1 06       	cpc	r15, r17
 46e:	81 f0       	breq	.+32     	; 0x490 <PutString+0xc8>
		uint8_t character = string[i];
 470:	f7 01       	movw	r30, r14
 472:	91 91       	ld	r25, Z+
 474:	7f 01       	movw	r14, r30
	 * uint8_t data - data to be displayed
	 * Returns: void.
	 */

	uint8_t high_nibble = (data)&0xF0;	/* High 4bit nibble of the character */
	uint8_t low_nibble  = (data)&0x0F;	/* Low 4bit nibble of the character */
 476:	29 2f       	mov	r18, r25
 478:	2f 70       	andi	r18, 0x0F	; 15
	/* Sends data to the screen.
	 * uint8_t data - data to be displayed
	 * Returns: void.
	 */

	uint8_t high_nibble = (data)&0xF0;	/* High 4bit nibble of the character */
 47a:	49 2f       	mov	r20, r25
 47c:	40 7f       	andi	r20, 0xF0	; 240

	uint8_t NO_OF_BITS = sizeof(nibble)*8; 	/* Number of bits the nibble */
	uint8_t rev_nibble = 0;					/* Reversed nibble temporary variable */

	for (int i = 0; i < NO_OF_BITS; i++) {	/* Iterate through the bits */
		if((nibble & (1 << i)))
 47e:	50 e0       	ldi	r21, 0x00	; 0
 480:	94 ff       	sbrs	r25, 4
 482:	b2 cf       	rjmp	.-156    	; 0x3e8 <PutString+0x20>
 484:	3c e0       	ldi	r19, 0x0C	; 12
		   rev_nibble |= 1 << ((NO_OF_BITS - 1) - i);	/* Build reversed nibble */
 486:	88 e0       	ldi	r24, 0x08	; 8
 488:	b1 cf       	rjmp	.-158    	; 0x3ec <PutString+0x24>

	uint8_t NO_OF_BITS = sizeof(nibble)*8; 	/* Number of bits the nibble */
	uint8_t rev_nibble = 0;					/* Reversed nibble temporary variable */

	for (int i = 0; i < NO_OF_BITS; i++) {	/* Iterate through the bits */
		if((nibble & (1 << i)))
 48a:	40 ec       	ldi	r20, 0xC0	; 192
		   rev_nibble |= 1 << ((NO_OF_BITS - 1) - i);	/* Build reversed nibble */
 48c:	d0 e8       	ldi	r29, 0x80	; 128
 48e:	be cf       	rjmp	.-132    	; 0x40c <PutString+0x44>

	for (int i = 0; i < NO_OF_CHARS; i++) { 	/* Iterate through the char array */
		uint8_t character = string[i];
		PutChar(character);						/* Put a char at a time on the screen */
	}
}
 490:	df 91       	pop	r29
 492:	cf 91       	pop	r28
 494:	1f 91       	pop	r17
 496:	0f 91       	pop	r16
 498:	ff 90       	pop	r15
 49a:	ef 90       	pop	r14
 49c:	08 95       	ret

0000049e <ReverseNibble>:

/* Utility functions */

uint8_t ReverseNibble(uint8_t nibble) {
 49e:	28 2f       	mov	r18, r24
 4a0:	30 e0       	ldi	r19, 0x00	; 0
 4a2:	80 ff       	sbrs	r24, 0
 4a4:	23 c0       	rjmp	.+70     	; 0x4ec <ReverseNibble+0x4e>
 4a6:	90 e8       	ldi	r25, 0x80	; 128
	uint8_t NO_OF_BITS = sizeof(nibble)*8; 	/* Number of bits the nibble */
	uint8_t rev_nibble = 0;					/* Reversed nibble temporary variable */

	for (int i = 0; i < NO_OF_BITS; i++) {	/* Iterate through the bits */
		if((nibble & (1 << i)))
		   rev_nibble |= 1 << ((NO_OF_BITS - 1) - i);	/* Build reversed nibble */
 4a8:	89 2f       	mov	r24, r25
 4aa:	80 64       	ori	r24, 0x40	; 64
 4ac:	21 ff       	sbrs	r18, 1
 4ae:	89 2f       	mov	r24, r25
 4b0:	98 2f       	mov	r25, r24
 4b2:	90 62       	ori	r25, 0x20	; 32
 4b4:	22 fd       	sbrc	r18, 2
 4b6:	89 2f       	mov	r24, r25
 4b8:	98 2f       	mov	r25, r24
 4ba:	90 61       	ori	r25, 0x10	; 16
 4bc:	23 fd       	sbrc	r18, 3
 4be:	89 2f       	mov	r24, r25
 4c0:	98 2f       	mov	r25, r24
 4c2:	98 60       	ori	r25, 0x08	; 8
 4c4:	24 fd       	sbrc	r18, 4
 4c6:	89 2f       	mov	r24, r25
 4c8:	98 2f       	mov	r25, r24
 4ca:	94 60       	ori	r25, 0x04	; 4
 4cc:	25 fd       	sbrc	r18, 5
 4ce:	89 2f       	mov	r24, r25
 4d0:	98 2f       	mov	r25, r24
 4d2:	92 60       	ori	r25, 0x02	; 2
 4d4:	26 fd       	sbrc	r18, 6
 4d6:	89 2f       	mov	r24, r25
 4d8:	98 2f       	mov	r25, r24
 4da:	91 60       	ori	r25, 0x01	; 1

	uint8_t NO_OF_BITS = sizeof(nibble)*8; 	/* Number of bits the nibble */
	uint8_t rev_nibble = 0;					/* Reversed nibble temporary variable */

	for (int i = 0; i < NO_OF_BITS; i++) {	/* Iterate through the bits */
		if((nibble & (1 << i)))
 4dc:	22 0f       	add	r18, r18
 4de:	23 2f       	mov	r18, r19
 4e0:	22 1f       	adc	r18, r18
 4e2:	33 0b       	sbc	r19, r19
 4e4:	23 2b       	or	r18, r19
 4e6:	09 f0       	breq	.+2      	; 0x4ea <ReverseNibble+0x4c>
 4e8:	89 2f       	mov	r24, r25
		   rev_nibble |= 1 << ((NO_OF_BITS - 1) - i);	/* Build reversed nibble */
	}

	return rev_nibble;
}
 4ea:	08 95       	ret
 4ec:	90 e0       	ldi	r25, 0x00	; 0
 4ee:	dc cf       	rjmp	.-72     	; 0x4a8 <ReverseNibble+0xa>

000004f0 <SPIMasterInit>:
	/* Set up SPI Master
	 * Returns: void.
	 */

	/* Set MOSI, SCK and SS output, MISO as input */
	DDR_SPI |= (1<<DD_MOSI)|(1<<DD_SCK)|(1<<DD_SS);
 4f0:	84 b1       	in	r24, 0x04	; 4
 4f2:	8c 62       	ori	r24, 0x2C	; 44
 4f4:	84 b9       	out	0x04, r24	; 4

	DDR_SPI &= ~(1<<DD_MISO);
 4f6:	24 98       	cbi	0x04, 4	; 4

	PORTB |= (1<<DD_SS);
 4f8:	2a 9a       	sbi	0x05, 2	; 5

	/* Enable SPI, Master, set clock rate fck/16 */
	SPCR = (1<<SPE)|(1<<MSTR)|(0<<SPR0)|(1<<SPR1);
 4fa:	82 e5       	ldi	r24, 0x52	; 82
 4fc:	8c bd       	out	0x2c, r24	; 44

	SPSR &= ~(1<<SPI2X);
 4fe:	8d b5       	in	r24, 0x2d	; 45
 500:	8e 7f       	andi	r24, 0xFE	; 254
 502:	8d bd       	out	0x2d, r24	; 45
 504:	08 95       	ret

00000506 <SPIMasterTransmit>:
	 */

	uint8_t flush_buffer; /* Buffer to flush the existent data on the SPI register */

	/* Start transmission */
	SPDR = data;
 506:	8e bd       	out	0x2e, r24	; 46

	/* Wait for transmission complete */
	while (!(SPSR & (1<<SPIF)));
 508:	0d b4       	in	r0, 0x2d	; 45
 50a:	07 fe       	sbrs	r0, 7
 50c:	fd cf       	rjmp	.-6      	; 0x508 <SPIMasterTransmit+0x2>
 50e:	89 e0       	ldi	r24, 0x09	; 9
 510:	90 e0       	ldi	r25, 0x00	; 0
	 */

	uint8_t NO_OF_BITS = 8; /* Number of bits of the shift register */

	for (int i = 0; i < NO_OF_BITS + 1; i++) {	/* Iterate through the number of bits of the register */
		PORTB |= (1<<DD_SS);	/* Drive the latch to high */
 512:	2a 9a       	sbi	0x05, 2	; 5
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 514:	00 00       	nop
		_delay_us(1);			/* Latch hold time */
		PORTB &= ~(1<<DD_SS);	/* Drive the latch to low */
 516:	2a 98       	cbi	0x05, 2	; 5
 518:	01 97       	sbiw	r24, 0x01	; 1
	 * Returns: void
	 */

	uint8_t NO_OF_BITS = 8; /* Number of bits of the shift register */

	for (int i = 0; i < NO_OF_BITS + 1; i++) {	/* Iterate through the number of bits of the register */
 51a:	d9 f7       	brne	.-10     	; 0x512 <SPIMasterTransmit+0xc>
 51c:	00 00       	nop
	/* Wait for transmission complete */
	while (!(SPSR & (1<<SPIF)));

	FlushShiftRegister(); 	/* Flush the shift register to put the byte into the screen */

	flush_buffer = SPDR;	/* Flush the SPI register */
 51e:	8e b5       	in	r24, 0x2e	; 46
 520:	08 95       	ret

00000522 <FlushShiftRegister>:
}

void FlushShiftRegister(void) {
 522:	89 e0       	ldi	r24, 0x09	; 9
 524:	90 e0       	ldi	r25, 0x00	; 0
	 */

	uint8_t NO_OF_BITS = 8; /* Number of bits of the shift register */

	for (int i = 0; i < NO_OF_BITS + 1; i++) {	/* Iterate through the number of bits of the register */
		PORTB |= (1<<DD_SS);	/* Drive the latch to high */
 526:	2a 9a       	sbi	0x05, 2	; 5
 528:	00 00       	nop
		_delay_us(1);			/* Latch hold time */
		PORTB &= ~(1<<DD_SS);	/* Drive the latch to low */
 52a:	2a 98       	cbi	0x05, 2	; 5
 52c:	01 97       	sbiw	r24, 0x01	; 1
	 * Returns: void
	 */

	uint8_t NO_OF_BITS = 8; /* Number of bits of the shift register */

	for (int i = 0; i < NO_OF_BITS + 1; i++) {	/* Iterate through the number of bits of the register */
 52e:	d9 f7       	brne	.-10     	; 0x526 <FlushShiftRegister+0x4>
 530:	00 00       	nop
 532:	08 95       	ret

00000534 <main>:
#include <I2C_comms.h>
#include <LCD1602A.h>

int main(void) {
	return 0;
}
 534:	80 e0       	ldi	r24, 0x00	; 0
 536:	90 e0       	ldi	r25, 0x00	; 0
 538:	08 95       	ret

0000053a <_exit>:
 53a:	f8 94       	cli

0000053c <__stop_program>:
 53c:	ff cf       	rjmp	.-2      	; 0x53c <__stop_program>
